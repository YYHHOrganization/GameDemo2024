# 《原神》沙漠效果复刻

主要参考链接：https://zhuanlan.zhihu.com/p/568051545

这里除了上述链接中博客的基本内容，也加入了一些自己的理解，并争取对代码进行一定的修改，让效果更好一点。



# 一、基本原理

## 1.绘制的基本原理

——对于绘制，我们可以模仿PS的绘制过程来解决这个问题。

![动图](./assets/v2-e8cb110290e08c658cf4ae9511150f52_b.webp)



​	这个绘制（添加新的“圆点”）的过程可以描述为一个迭代、或者说递归的过程，即用原图经过“加点”方法f(x)处理输出新图，而新图作为下次“加点”处理的原图输入，并重复这个过程。

`𝑇𝑒𝑥𝑡𝑢𝑟𝑒_{𝑛+1}=𝑓(𝑇𝑒𝑥𝑡𝑢𝑟𝑒_{𝑛})`

​	如此一来，在shader中只需计算和新加的那一个“圆点”相关的数据即可，而之前的结果都保存在了一张图像中。这个过程的实现方法也不唯一，可以用Compute shader来实现，在这篇博客中使用的是tesselation方法来实现。



## 2.轨迹体积的实现

### （1）置换贴图（displacement map）

​	一般是一张记录了表面凹凸程度（高度）的灰度图，可以用它在顶点shader中改变模型的顶点位置（实际上模型本身没变，只是最终看上去的效果变了。**最常见的套路就是下面这样沿法线方向膨胀**）。以下是两个应用displacement map需要注意的问题：

- 轨迹的形状可能存在外围比地表高，内部比地表低的情况，既可以拱出来又可以压下去，所以这里可以对displacement map做一个映射，把【0，1】的灰度值映射到【-1，1】，作为顶点沿法线偏移的量；
- 直接使用displacement map的话，阴影是错误的，解决方案是用法线贴图。虽然法线可以基于高度图在shader中实时计算，但考虑到性能开销与效果，这里还是用现成的法线贴图来做。这里可以做一个小优化，充分利用颜色通道，将法线信息存到图像的RGB通道，高度存到A通道中。

综合以上两点可以得到类似于下面的笔刷贴图：

![img](./assets/v2-7f96c17a5b195fba1cce50dbd8d43ab5_r.jpg)

> 需要注意的是，因为这里的法线是我们自定义的编码方式，所以U3D的图像导入设置中不能选NormalMap，shader中也不能用UnpackNormal解码。并且因为存储的是数据不是颜色，所以不能勾选sRGB。（原因可以参考我的[这篇文章](https://link.zhihu.com/?target=https%3A//www.bilibili.com/read/cv18385963%3Fspm_id_from%3D333.999.0.0)中末尾关于线性和Gamma空间的陈述）。**也就是说这张图需要取消勾选sRGB。**

如果只是用上面的displacement map和法线贴图，则效果还是不会太好，这是因为mesh的”分辨率“太低了，**解决方案是对其进行曲面细分。**

------



### （2）曲面细分

曲面细分和几何shader是渲染管线中的两个可选阶段。一般我们写的shader，尤其是移动端shader只会用到顶点和片段shader，而完整的流程则是顶点->曲面细分->几何->片段。

按博客作者的理解（注：我个人觉得也差不多，反正能把代码写明白就行），曲面细分阶段又可以进一步分成【顶点阶段数据接收】、【细分规则配置】、【计算插值权重】和【细分后的顶点属性计算】四部分。若要使用曲面细分shader，首先需要在Pass内的开头补上以下内容（类似于顶点着色器和片元着色器的声明）：

```glsl
#pragma hull hs
#pragma domain ds
```

下面对各阶段的解析只讨论图元是三角形时的情况。

#### （a）顶点阶段数据接收

曲面细分的位置在顶点阶段后。参照顶点与片段之间利用结构体及对应的方法传递数据的方式（后面几个阶段的数据交换也都类似），曲面细分也需要定义一个结构体来接收顶点阶段的数据，比如下面这个样子：

```glsl
//顶点shader
struct a2v
{
    float4 posOS	: POSITION;
    float3 nDirOS : NORMAL;
    float4 tDirOS : TANGENT;
    float2 uv0  : TEXCOORD0;
};
struct v2t  //曲面细分结构体
{
    float3 posWS	: TEXCOORD0;
    float3 nDirWS : TEXCOORD1;
    float3 tDirWS : TEXCOORD2;
    float3 bDirWS    : TEXCOORD3;
    float2 uv0  : TEXCOORD4;
    float2 uv_Rut : TEXCOORD5; //先忽略这个，后面会说
};
```

此时顶点着色器是这样的：

```glsl
v2t vert(a2v i)
{
    v2t o;

    //坐标
    o.posWS = TransformObjectToWorld(i.posOS.xyz);

    //向量
    o.nDirWS = TransformObjectToWorldNormal(i.nDirOS);
    o.tDirWS = TransformObjectToWorldDir(i.tDirOS.xyz);
    o.bDirWS = cross(o.nDirWS, o.tDirWS) * i.tDirOS.w;

    //UV
    o.uv0 = i.uv0; 
    o.uv_Rut = float2(Remap(_PaintRect.x, _PaintRect.z, o.posWS.x), Remap(_PaintRect.y, _PaintRect.w, o.posWS.z)); //先忽略这个，后面会说

    return o;
}
```

------



#### （b）细分规则配置

即如何对一个三角面进行细分。在曲面细分的流程中，我们需要设置三角形各边要分成几段，以及三角形内部有几个新加的点（实际上不是点的数量。内部点的细分数并不直观）。首先，我们需要声明下面这么个结构体用来存储细分配置：

```glsl
//对三角面或其他形式图元进行细分的配置
struct TessParam
{
    float EdgeTess[3]	: SV_TessFactor;//各边细分数
    float InsideTess	    : SV_InsideTessFactor;//内部点细分数
};
```

紧接着这个结构体下面写这么个方法来算具体怎么分，后面几个阶段也是类似的格式：

```glsl
TessParam ConstantHS(InputPatch<v2t, 3> i, uint id : SV_PrimitiveID)
{
  TessParam o;

  o.EdgeTess[0] = 第1条边的细分段数;
  o.EdgeTess[1] = 第2条边的细分段数;
  o.EdgeTess[2] = 第3条边的细分段数;
  o.InsideTess = 内部细分点系数;

  return o;
}
```

上面这个方法在运行时会在原模型的每个三角面上跑一遍。参数列表中的`i`可以获得之前在顶点阶段传到曲面细分结构体里的数据，并且是三份（一个三角面上的三个顶点）。如果需要做一些局部细分的优化，可能就需要用到它。

> 注意：这里可以想到一个优化点，即在需要足迹的地方使用tessellation，而在比如离角色脚印很远的位置则不需要进行tessellation，这个优化策略会在后面的具体代码分析部分进行分析。

我们先来看一下这两种参数对模型的实际影响：

![动图](./assets/v2-baa97ab7c2c96040543c95be105162cd_b.webp)

- 右边参数的xyz分量对应边的细分段数，w对应内部细分点系数。

  > 需要特别说明的是这里有个坑，如果把三条边的细分段数公开成三个不同的参数来控制会出问题，网格会完全消失（或闪烁），但博客作者不清楚原因。以防万一如果后面需要对每个参数单独控制的话给个`float3`吧，而不是三个float。

- 对于这几个参数，其中的EdgeTess很直观，给多少，对应的边就会被分成几段；而对于InsideTess，经观察可以发现它只会影响内层三角形的细分点排列方式，也就是说EdgeTess与InsideTess是互相独立的。
- 以一些简单的等差数列知识可以算出来，InsideTess系数与内部的细分点个数间的关系如下（注：不过这个在实际写代码的时候也不是那么需要关心）：
  - ![image-20240717213728826](./assets/image-20240717213728826.png)——其中N是三角形内部增加的点的个数；x是InsideTess给的数；k在x是奇数时为0，偶数时为1。

------



#### （c）计算插值权重

​	这个阶段是**不可编程的**。他会根据我们之前和下面的细分配置在硬件内部进行计算，并得到每个新顶点的插值权重，或者说所谓的“重心空间坐标”（其实某种层面上类似于片段shader前的光栅化线性插值阶段，只不过这里插值计算的是顶点而不是像素。并且这一步只是得到每个顶点的插值权重，真正的混合需要我们在下一个阶段手动计算）。但是在此之前，还需要写一些配置方面的东西：

```glsl
//将原模型顶点属性按指定图元打包？
struct TessOut
{
    float3 posWS	: TEXCOORD0;
    float3 nDirWS : TEXCOORD1;
    float3 tDirWS : TEXCOORD2;
    float3 bDirWS    : TEXCOORD3;
    float2 uv0  : TEXCOORD4;
    float2 uv_Rut : TEXCOORD5;
};
[domain("tri")]//图元类型
[partitioning("integer")]//曲面细分的过渡方式是整数还是小数
[outputtopology("triangle_cw")]//三角面正方向是顺时针还是逆时针
[outputcontrolpoints(3)]//输出的控制点数
[patchconstantfunc("ConstantHS")]//对应之前的细分因子配置阶段的方法名
[maxtessfactor(64.0)]//最大可能的细分段数
TessOut hs(InputPatch<v2t, 3> i, uint idx : SV_OutputControlPointID)//在此处进行的操作是对原模型的操作，而非细分后
    //目前来说就是直接赋值就好，没看出来具体有什么用，不影响写代码
{
    TessOut o;
    o.posWS = i[idx].posWS;
    o.nDirWS = i[idx].nDirWS;
    o.tDirWS = i[idx].tDirWS;
    o.bDirWS = i[idx].bDirWS;
    o.uv0 = i[idx].uv0;
    o.uv_Rut = i[idx].uv_Rut;
    return o;
}
```

> 这段中间的那几行中括号【】括起来的配置还是有一定影响的，但一般需要动的可能也就第二行。除了integer，可选的字段还有fractional_odd和fractional_even两种。后两种的效果类似，都是有个平滑过渡的过程。针对`[partitioning("integer")]`不同参数的区别可以看下面的链接：
>
> https://vdn6.vzuu.com/SD/58b4f3f6-3cd2-11ed-b64d-1636829a506b.mp4?pkey=AAUW9DHw1MLquNX-oQaPDlfL_qemBqxumJsW_uwud3zq8DauwmH7oi_6Ng5DM00-pleWWHeAS5PmCizCRWAn1jm1&bu=078babd7&c=avc.1.1&expiration=1721230816&f=mp4&pu=078babd7&v=ks6



#### （d）**细分后的顶点属性计算**

​	到这里就是细分着色器的最后一步了。这一步的方法其实相当于一般顶点-片段shader中的顶点阶段，像是2.1中的置换贴图法线膨胀算法或是其他常见的写在顶点阶段的算法就可以写在这里。只不过经过了前面的细分处理，**这里所处理的顶点不是原模型的顶点，而是细分后的所有顶点。**看代码：
```glsl
struct t2f
{
    float4 posCS	       : SV_POSITION;
    float3 posWS            : TEXCOORD7;
    float3 nDirWS       : TEXCOORD0;
    float3 tDirWS       : TEXCOORD1;
    float3 bDirWS       : TEXCOORD2;
    float3 vDirWS       : TEXCOORD3;
	//...后面代码分析中具体会说
};
[domain("tri")]
t2f ds(TessParam tessParam, float3 bary : SV_DomainLocation, const OutputPatch<TessOut, 3> i)
{
    t2f o;   

    //线性转换
    o.posWS = i[0].posWS * bary.x + i[1].posWS * bary.y + i[2].posWS * bary.z;
    o.nDirWS = i[0].nDirWS * bary.x + i[1].nDirWS * bary.y + i[2].nDirWS * bary.z;
    o.tDirWS = i[0].tDirWS * bary.x + i[1].tDirWS * bary.y + i[2].tDirWS * bary.z;
    o.bDirWS = i[0].bDirWS * bary.x + i[1].bDirWS * bary.y + i[2].bDirWS * bary.z;
    //...后面代码分析中具体会说

    return o;
}
```

其实这里的`ds`函数的传入参数之一`bary`指的就是重心坐标，而下面函数体内暂时展示的部分就是重心插值的思路。最终再把`t2f`作为片元着色器的输入参数即可：
```glsl
float4 frag(t2f i) : SV_Target
{
	//像素处理
}
```



#### （e）曲面细分着色器的其他参考资料

【1】https://blog.csdn.net/suixinger_lmh/article/details/125140224

【2】https://blog.csdn.net/ifenghua135792468/article/details/106851708/

【3】https://blog.csdn.net/WINDGRIN23313/article/details/120128498

------



### （3）Displacement map + tessellation

基于之前做的[沙漠材质球](https://link.zhihu.com/?target=https%3A//www.bilibili.com/read/cv18488420%3Fspm_id_from%3D333.999.0.0)，将上述两种技术加进去，便可得到以下效果。至于具体的代码细节和优化的思路会放在后面去说。

------



## 3.轨迹的动态绘制

### （1）`Graphics.Blit`

这部分是在C#脚本当中去写的。（注：我以前以为`Graphics.Blit`是不能在URP中写的，看起来应该是可以！！），核心部分是下面的代码：
```c#
public RenderTexture paintRT;//轨迹渲染纹理 RGB法线 A高度
Material paintMat;//绘制处理用的材质
void Paint(Texture2D brushTex/*其他参数*/)
{
  //其他计算
  
  //绘制材质参数配置
  paintMat.SetTexture("_BrushTex", brushTex);//笔刷贴图
  /*其他参数设置···*/
  
  //纹理交换
  RenderTexture tempRT = RenderTexture.GetTemporary(paintRT.descriptor);
  Graphics.Blit(paintRT, tempRT, paintMat, 0);
  Graphics.Blit(tempRT, paintRT);
  RenderTexture.ReleaseTemporary(tempRT);
}
```

> 对上述代码的解读：
>
> - 定义一个Paint方法。其中，paintRT是旧的轨迹图，同时也是地形使用的displacement map+normal map； paintMat是我们一会要写的绘制用的shader实例化出来的一个材质；brushTex是在本次绘制中使用的笔刷贴图（一个法线高度混合图，可以看原博客的2.1部分，就是一个有displacement map和normal map的笔刷贴图）。
> - 完成材质的参数传递后，我们先用`RenderTexture.GetTemporary`方法创建一个交换用的临时RT（说是用这个方法的性能比较好）；
> - 然后`Graphics.Blit(paintRT, tempRT, paintMat, 0)`这句的意思是：【把paintRT用paintMat处理一次后的图像传给tempRT】（0的意思是使用shader中的第几个pass，一般就用第一个，尤其本文的URP管线）。**需要注意的是，Blit会默认把paintRT传给shader中名为_MainTex的变量，所以写shader时名字要对应；**
> - 接着，`Graphics.Blit(tempRT, paintRT)`是将tempRT的结果传回paintRT，完成一次迭代过程；最后一定要用`ReleaseTemporary`手动释放临时RT的内存！（否则就等着内存爆炸吧，不要问我怎么知道的）



### （2）笔刷绘制shader

​	上面的Blit方法需要以一个paintMat作为处理材质，其对应的便是接下来的绘制shader。 结合前面的分析与上述过程，我们绘制用的shader其实只需要关注“单步操作”即可，即“如何把一张笔刷图贴到旧的轨迹图上去”。

先考虑一下，这个shader可能需要用到什么参数。

- 首先，旧的轨迹图和笔刷图是必须的；
- 然后是“在哪画”，即笔刷的UV坐标（这里需要补充一下，Graphics.Blit方法实际上是在一个UV范围是0~1的方形网格上进行相关计算的，所以UV坐标也就相当于贴图归一化的像素坐标）；
- 还有“画多大”，即笔刷在UV空间中的半径；
- 最后还可以加个强度，或者说透明度。

​	显然，如果要把”笔刷“绘制在地形上，这里一定需要一步**法线贴图混合的操作**。**法线贴图混合的操作强烈建议阅读这个文章：https://www.gameres.com/896279.html**（具体的数学暂时不需要了解，但要做到拿来即用）。

​	法线采用之前一篇文中说过的[偏导数](https://link.zhihu.com/?target=https%3A//www.bilibili.com/read/cv18524352%3Fspm_id_from%3D333.999.0.0)的混合方式，高度直接在解码后相加，最后编码（特别说明，原神中的高度混合显然不是这种方式。经过我尝试，它应该是一种比较后取最大/最小的算法，这个后面的博客好像有说。==todo：后面看到的话再回来补充吧==）。

```c#
//地形法线
float3 nDirTS = UnpackNormal(tex2D(_NormalMap, i.uv_Main)); //这个指的是沙子自身的法线贴图
nDirTS.xy *= _NormalInt;

//轨迹法线
float4 var_RutTex = tex2D(_RutRTTex, i.uv_Rut); //这个指的是笔刷，即轨迹渲染纹理，从上面C#脚本的paintRT参数传入
float3 nDirTS_Rut = (2.0 * var_RutTex.xyz - 1.0); //自己做的法线+displacement map，拆出RGB通道（代表法线）并自行unpack
nDirTS_Rut.xy *= _RutHeight * _RutNormalInt;

//法线混合
nDirTS = normalize(float3(nDirTS.xy / nDirTS.z + nDirTS_Rut.xy / nDirTS_Rut.z, 1.0)); //参考https://www.gameres.com/896279.html里面的Partial Derivative Blending
```

> 注：本篇参考的博客在这句`nDirTS = normalize(float3(nDirTS.xy / nDirTS.z + nDirTS_Rut.xy / nDirTS_Rut.z, 1.0));`中并没有normalize的操作，不过在后面TBN矩阵相乘的时候有做normalize操作，所以应该也没啥问题，这里提前normalize一下，保证跟Partial Derivative Blending方法保持一致。

参考博客中，作者用SD做了一个简易笔刷：

![img](./assets/v2-6147acf78b5d8e8ac35083ad7fb56f86_r.jpg)

> 注：SD用的还不是很熟，但是感觉应该不难，也是连连看连出来的。

输入后可以得到下面的效果（为方便演示，左半边显示法线，右半边显示高度），可以看到混合的效果还是可以的：

![动图](./assets/v2-21087e86056ee075ca0cc8ed7806fd8e_b.webp)

​	至于笔刷局部绘制的实现，可以参考以下伪代码（即在原本的UV0中挖出一块方形来做局部UV），并且相同的思路在之后的地形绘制范围跟随中也会再次用到：

```glsl
float Remap(float min, float max, float input)  //remap函数就是把input映射到min到max之间
{
  float k = 1.0 / (max - min);
  float b = -min * k;
  return k * input + b;
}

float2 _BrushPosTS;//笔刷中心UV坐标
float _BrushRadius;//笔刷归一化半径
float2 uv00 = _BrushPosTS - _BrushRadius;
float2 uv11 = _BrushPosTS + _BrushRadius;
float2 uv_Brush = float2(Remap(uv00.x, uv11.x, i.uv0.x), Remap(uv00.y, uv11.y, i.uv0.y));
```



------

